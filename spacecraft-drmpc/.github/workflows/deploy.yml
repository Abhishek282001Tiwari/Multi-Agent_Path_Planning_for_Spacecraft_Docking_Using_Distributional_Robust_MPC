name: Deployment Pipeline

on:
  workflow_run:
    workflows: ["Spacecraft Simulation CI/CD Pipeline"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: 'Container image tag to deploy'
        required: false
        default: 'latest'
        type: string
      force_deploy:
        description: 'Force deployment even if tests failed'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  KUBECTL_VERSION: 'v1.28.0'
  HELM_VERSION: 'v3.12.0'

jobs:
  # Pre-deployment validation
  pre-deployment:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      environment: ${{ steps.check.outputs.environment }}
      image_tag: ${{ steps.check.outputs.image_tag }}
    
    steps:
    - name: Check deployment conditions
      id: check
      run: |
        # Determine if we should deploy based on trigger and conditions
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "Manual deployment triggered"
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "workflow_run" ]; then
          if [ "${{ github.event.workflow_run.conclusion }}" = "success" ]; then
            echo "Automatic deployment after successful CI"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "Forced deployment despite CI failure"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "CI failed, skipping deployment"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "Unknown trigger, skipping deployment"
          echo "should_deploy=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Log deployment decision
      run: |
        echo "Should deploy: ${{ steps.check.outputs.should_deploy }}"
        echo "Environment: ${{ steps.check.outputs.environment }}"
        echo "Image tag: ${{ steps.check.outputs.image_tag }}"

  # Staging Deployment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should_deploy == 'true' && needs.pre-deployment.outputs.environment == 'staging'
    
    environment:
      name: staging
      url: https://staging.spacecraft-sim.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}
    
    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Configure kubectl for staging
      run: |
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > $HOME/.kubeconfig
        export KUBECONFIG=$HOME/.kubeconfig
        kubectl config use-context staging
        kubectl cluster-info
    
    - name: Prepare deployment manifests
      run: |
        # Update image tags in Kubernetes manifests
        sed -i "s|image: .*spacecraft-drmpc:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment.outputs.image_tag }}|g" k8s/deployment.yaml
        
        # Update environment-specific configurations
        sed -i 's|environment: production|environment: staging|g' k8s/*.yaml
        sed -i 's|spacecraft-sim.example.com|staging.spacecraft-sim.example.com|g' k8s/ingress.yaml
        
        # Validate manifests
        kubectl apply --dry-run=client --validate=true -f k8s/
    
    - name: Deploy to staging namespace
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Create namespace if it doesn't exist
        kubectl create namespace spacecraft-staging --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply secrets (staging-specific)
        kubectl apply -f k8s/secrets.yaml -n spacecraft-staging
        
        # Apply configuration
        kubectl apply -f k8s/configmap.yaml -n spacecraft-staging
        
        # Deploy application
        kubectl apply -f k8s/deployment.yaml -n spacecraft-staging
        kubectl apply -f k8s/service.yaml -n spacecraft-staging
        kubectl apply -f k8s/ingress.yaml -n spacecraft-staging
        
        # Wait for deployment to complete
        kubectl rollout status deployment/spacecraft-drmpc -n spacecraft-staging --timeout=600s
    
    - name: Run post-deployment tests
      run: |
        # Wait for services to be ready
        sleep 30
        
        # Health check
        kubectl get pods -n spacecraft-staging
        
        # Test application endpoints
        STAGING_URL="https://staging.spacecraft-sim.example.com"
        
        # Basic connectivity test
        curl -f "$STAGING_URL/health" || exit 1
        
        # API functionality test
        curl -f "$STAGING_URL/api/v1/status" || exit 1
        
        echo "Staging deployment validation passed"
    
    - name: Update deployment status
      if: always()
      run: |
        if [ $? -eq 0 ]; then
          echo "✅ Staging deployment successful"
        else
          echo "❌ Staging deployment failed"
          exit 1
        fi

  # Production Deployment (Manual Approval Required)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [pre-deployment, deploy-staging]
    if: |
      needs.pre-deployment.outputs.should_deploy == 'true' && 
      needs.pre-deployment.outputs.environment == 'production' &&
      (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped')
    
    environment:
      name: production
      url: https://spacecraft-sim.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}
    
    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Configure kubectl for production
      run: |
        echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > $HOME/.kubeconfig
        export KUBECONFIG=$HOME/.kubeconfig
        kubectl config use-context production
        kubectl cluster-info
    
    - name: Pre-deployment backup
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Backup current deployment configuration
        kubectl get deployment spacecraft-drmpc -n spacecraft-sim -o yaml > backup-deployment.yaml
        kubectl get configmap spacecraft-config -n spacecraft-sim -o yaml > backup-configmap.yaml
        
        # Backup database (if configured)
        if [ -n "${{ secrets.DATABASE_BACKUP_SCRIPT }}" ]; then
          echo "${{ secrets.DATABASE_BACKUP_SCRIPT }}" | base64 -d > backup-db.sh
          chmod +x backup-db.sh
          ./backup-db.sh
        fi
    
    - name: Blue-Green Deployment Setup
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Check current deployment
        CURRENT_REPLICAS=$(kubectl get deployment spacecraft-drmpc -n spacecraft-sim -o jsonpath='{.spec.replicas}')
        
        # Scale up new version alongside current
        kubectl patch deployment spacecraft-drmpc -n spacecraft-sim -p '{
          "spec": {
            "replicas": '$((CURRENT_REPLICAS * 2))',
            "template": {
              "spec": {
                "containers": [{
                  "name": "spacecraft-drmpc",
                  "image": "'${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment.outputs.image_tag }}'"
                }]
              }
            }
          }
        }'
        
        # Wait for new pods to be ready
        kubectl rollout status deployment/spacecraft-drmpc -n spacecraft-sim --timeout=900s
    
    - name: Production smoke tests
      run: |
        # Wait for stabilization
        sleep 60
        
        # Comprehensive health checks
        PRODUCTION_URL="https://spacecraft-sim.example.com"
        
        # Health endpoint
        for i in {1..10}; do
          if curl -f "$PRODUCTION_URL/health"; then
            echo "Health check $i passed"
            break
          else
            echo "Health check $i failed, retrying..."
            sleep 10
          fi
        done
        
        # API functionality
        curl -f "$PRODUCTION_URL/api/v1/status" || exit 1
        
        # Metrics endpoint
        curl -f "$PRODUCTION_URL/metrics" || exit 1
        
        # Database connectivity (through API)
        curl -f "$PRODUCTION_URL/api/v1/health/database" || exit 1
        
        echo "Production smoke tests passed"
    
    - name: Traffic switch and scale down
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Get original replica count
        ORIGINAL_REPLICAS=$(echo $CURRENT_REPLICAS)
        
        # Update service selector to use new pods only
        kubectl patch service spacecraft-drmpc -n spacecraft-sim -p '{
          "spec": {
            "selector": {
              "app": "spacecraft-drmpc",
              "version": "'${{ needs.pre-deployment.outputs.image_tag }}'"
            }
          }
        }'
        
        # Scale back to original replica count
        kubectl scale deployment spacecraft-drmpc --replicas=$ORIGINAL_REPLICAS -n spacecraft-sim
        
        # Wait for scale-down
        kubectl rollout status deployment/spacecraft-drmpc -n spacecraft-sim --timeout=300s
    
    - name: Post-deployment validation
      run: |
        # Extended validation tests
        PRODUCTION_URL="https://spacecraft-sim.example.com"
        
        # Load test (basic)
        for i in {1..50}; do
          curl -s "$PRODUCTION_URL/api/v1/status" > /dev/null || echo "Request $i failed"
        done
        
        # Performance check
        RESPONSE_TIME=$(curl -w "%{time_total}" -s "$PRODUCTION_URL/api/v1/status" -o /dev/null)
        if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
          echo "Warning: Response time is high: ${RESPONSE_TIME}s"
        fi
        
        # Monitor error rates for 5 minutes
        echo "Monitoring error rates..."
        sleep 300
        
        # Check application logs for errors
        ERROR_COUNT=$(kubectl logs -l app=spacecraft-drmpc -n spacecraft-sim --since=5m | grep -c "ERROR" || echo "0")
        if [ "$ERROR_COUNT" -gt 10 ]; then
          echo "High error count detected: $ERROR_COUNT"
          exit 1
        fi
        
        echo "Production deployment validation completed successfully"
    
    - name: Update deployment status
      if: always()
      run: |
        if [ $? -eq 0 ]; then
          echo "✅ Production deployment successful"
        else
          echo "❌ Production deployment failed"
          exit 1
        fi
    
    - name: Rollback on failure
      if: failure()
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        echo "🔄 Rolling back production deployment..."
        
        # Restore previous deployment
        kubectl apply -f backup-deployment.yaml
        kubectl apply -f backup-configmap.yaml
        
        # Wait for rollback
        kubectl rollout status deployment/spacecraft-drmpc -n spacecraft-sim --timeout=600s
        
        echo "Rollback completed"

  # Database Migration (Production Only)
  migrate-database:
    name: Database Migration
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [pre-deployment, deploy-production]
    if: needs.pre-deployment.outputs.environment == 'production' && needs.deploy-production.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}
    
    - name: Configure kubectl
      run: |
        echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > $HOME/.kubeconfig
        export KUBECONFIG=$HOME/.kubeconfig
        kubectl config use-context production
    
    - name: Run database migrations
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Create migration job
        cat <<EOF | kubectl apply -f -
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: spacecraft-migration-$(date +%s)
          namespace: spacecraft-sim
        spec:
          template:
            spec:
              containers:
              - name: migration
                image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment.outputs.image_tag }}
                command: ["python", "/app/migrate.py"]
                env:
                - name: DATABASE_URL
                  valueFrom:
                    secretKeyRef:
                      name: spacecraft-secrets
                      key: database-url
              restartPolicy: Never
          backoffLimit: 3
        EOF
        
        # Wait for migration to complete
        JOB_NAME="spacecraft-migration-$(date +%s)"
        kubectl wait --for=condition=complete --timeout=1800s job/$JOB_NAME -n spacecraft-sim
        
        # Check migration logs
        kubectl logs job/$JOB_NAME -n spacecraft-sim

  # Performance monitoring post-deployment
  performance-monitoring:
    name: Performance Monitoring
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [deploy-production, deploy-staging]
    if: always() && (needs.deploy-production.result == 'success' || needs.deploy-staging.result == 'success')
    
    steps:
    - name: Determine environment
      id: env
      run: |
        if [ "${{ needs.deploy-production.result }}" = "success" ]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "url=https://spacecraft-sim.example.com" >> $GITHUB_OUTPUT
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "url=https://staging.spacecraft-sim.example.com" >> $GITHUB_OUTPUT
        fi
    
    - name: Performance baseline test
      run: |
        # Run basic performance tests against deployed environment
        BASE_URL="${{ steps.env.outputs.url }}"
        
        echo "Running performance tests against $BASE_URL"
        
        # Response time test
        for endpoint in "/health" "/api/v1/status" "/metrics"; do
          echo "Testing $endpoint"
          for i in {1..10}; do
            TIME=$(curl -w "%{time_total}" -s "$BASE_URL$endpoint" -o /dev/null)
            echo "Response time: ${TIME}s"
          done
        done
        
        # Concurrent users simulation
        echo "Testing concurrent load..."
        for i in {1..20}; do
          curl -s "$BASE_URL/api/v1/status" > /dev/null &
        done
        wait
        
        echo "Performance tests completed"

  # Notification and Documentation Update
  post-deployment:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    if: always()
    needs: [deploy-production, deploy-staging, migrate-database, performance-monitoring]
    
    steps:
    - name: Determine deployment status
      id: status
      run: |
        if [ "${{ needs.deploy-production.result }}" = "success" ]; then
          echo "status=production-success" >> $GITHUB_OUTPUT
          echo "environment=production" >> $GITHUB_OUTPUT
        elif [ "${{ needs.deploy-staging.result }}" = "success" ]; then
          echo "status=staging-success" >> $GITHUB_OUTPUT
          echo "environment=staging" >> $GITHUB_OUTPUT
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "environment=unknown" >> $GITHUB_OUTPUT
        fi
    
    - name: Send deployment notification
      if: env.SLACK_WEBHOOK_URL != ''
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            "text": "🚀 Spacecraft Simulation Deployment",
            "attachments": [
              {
                "color": "${{ steps.status.outputs.status == 'failed' && 'danger' || 'good' }}",
                "fields": [
                  {
                    "title": "Environment",
                    "value": "${{ steps.status.outputs.environment }}",
                    "short": true
                  },
                  {
                    "title": "Status",
                    "value": "${{ steps.status.outputs.status }}",
                    "short": true
                  },
                  {
                    "title": "Image Tag",
                    "value": "${{ needs.pre-deployment.outputs.image_tag }}",
                    "short": true
                  },
                  {
                    "title": "Commit",
                    "value": "${{ github.sha }}",
                    "short": true
                  }
                ]
              }
            ]
          }
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    
    - name: Update deployment documentation
      if: steps.status.outputs.status == 'production-success'
      run: |
        echo "Updating deployment documentation..."
        # This would typically update a deployment log or documentation
        echo "Deployment completed at $(date)" >> deployment-log.md
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment.outputs.image_tag }}" >> deployment-log.md